; interrupt.asm
; 
; Sets up the interrupt table and contains common interrupt handlers

[bits 32]
%include "../macro.incl.asm"

IDT_BASE_HIGH_OFFSET EQU 6

PIC1 EQU 0x20
PIC2 EQU 0xA0

PIC1_COMMAND EQU PIC1
PIC1_DATA EQU PIC1+1
PIC2_COMMAND EQU PIC2
PIC2_DATA EQU PIC2+1

ICW1_DISABLE EQU 0xFF ; Interrupt command word: initialization

extern vid_clear
extern vid_set_attribute
extern vid_print_string
extern vid_print_string_line
extern vid_advance_line

; macro: set_trap_handler
; Installs a trap interrupt handler
;
; Parameters: 1=vector, 2=handler
%macro set_trap_handler 2
	push %1
	push 0xF
	push %2
	call install_interrupt_handler
	clear_stack_ns(3)
%endmacro

; init_interrupt
; Set up the interrupt table and enables interrupts
global init_interrupt
init_interrupt:
	call setup_pic
	
	; set-up exception handler for:
	set_trap_handler 0x0, divide_by_zero_handler		; divide by zero
	set_trap_handler 0x8, double_fault_handler			; double fault
	set_trap_handler 0xB, segment_np_handler			; segment not present
	set_trap_handler 0xC, segment_overflow_handler		; stack segment fault
	set_trap_handler 0xD, gp_fault_handler				; general protection fault
	set_trap_handler 0x1E, security_exception_handler	; security exception (??)
	
	; load table
	lidt [idt_desc]
	
	sti					; Enable interrupts
	ret

; setup_pic
; Internal routine to set-up the pic so it won't trigger IRQ
; on reserved interrupt IDs (0-7), but above (higher than 0x1F)
setup_pic:
	; Start init sequence
	mov al, ICW1_DISABLE
	out PIC2_DATA, al
	out PIC1_DATA, al
	
	ret

; install_interrupt_handler
; Installs an interrupt handler for the specified interrupt type
;
; Input: vector (char)
;		 type (char) 0x5=task_gate, 0xE = interrupt_gate, 0xF=trap_gate
;		 handler (void *)
;
; Output: Nothing
;
; Registers touched: edx, eax
global install_interrupt_handler
install_interrupt_handler:
	; We need to calculate the initial offset
	mov eax, IDT_HANDLER_SIZE
	mul byte param_ns(2)
	add eax, idt
	
	mov edx, param_ns(0)						; handler
	mov [eax + IDT_HANDLER_LOW_OFFSET], dx		; set handler low offset
	shr edx, 16									; get high offset
	mov [eax + IDT_HANDLER_HIGH_OFFSET], dx		; set handler low offset
	
	mov dl, param_ns(1)							; type
	or dl, 0b1000_0000							; set as actived
	mov [eax + IDT_HANDLER_TYPE_OFFSET], dl		; set type
	
	mov [eax + IDT_SEG_OFFSET], cs				; set segment
	
	ret

; uninstall_interrupt_handler
; Uninstalls / deactivates an interrupt handler for the specified interrupt type
;
; Input: vector (char)
; Output: Nothing
;
; Registers touched: edx, eax
global uninstall_interrupt_handler
uninstall_interrupt_handler:
	; We need to calculate the initial offset
	mov eax, IDT_HANDLER_SIZE
	mul byte param_ns(2)
	add eax, idt
	
	mov dl, [eax + IDT_HANDLER_TYPE_OFFSET]		; get type
	and dl, 0b0111_1111							; set P flag off
	mov [eax + IDT_HANDLER_TYPE_OFFSET], dl		; set type
	
	ret

; internal macro: create_halt_trap_handler
; Creates an exception handler which prints the specified message and halts the system
;
; Parameters: 1=message
%macro create_halt_trap_handler 1
	cli	; Stop disturbing
	pushad
	
	; Create clean RSOD
	push 0x4E	; Red bg, yellow fg
	call vid_set_attribute
	clear_stack_ns(1)
	
	call vid_clear
	
	; Write generic error message
	push exMsgHeader
	call vid_print_string_line
	clear_stack_ns(1)
	
	call vid_advance_line
	
	push exMsg
	call vid_print_string_line
	clear_stack_ns(1)
	
	call vid_advance_line
	
	; Write specific error message
	push %1
	call vid_print_string
	clear_stack_ns(1)
	
	; Put system in permanent halt state
	popad
.resume:
	hlt
	jmp .resume
	iret
%endmacro

; internal macro: create_cont_trap_handler
; Creates an exception handler which prints the specified message and continues the system
;
; Parameters: 1=message
%macro create_cont_trap_handler 1
	cli	; Stop disturbing for duration of interrupt
	pushad
	
	; Create clean RSOD
	push 0x4E	; Red bg, yellow fg
	call vid_set_attribute
	clear_stack_ns(1)
	
	call vid_clear
	
	; Write generic error message
	push exMsg
	call vid_print_string_line
	clear_stack_ns(1)
	
	call vid_advance_line
	
	; Write specific error message
	push %1
	call vid_print_string
	clear_stack_ns(1)
	
	; Resume
	popad
	sti
	clear_stack_ns(1)
	iret
%endmacro

; Below CPU exception handlers are auto-generated by the macros above.
; For debugging purposes, they all start with a dummy instruction so
; GDB can properly attach to that
global divide_by_zero_handler
divide_by_zero_handler:
mov eax, eax
create_halt_trap_handler exDivideMsg

global segment_np_handler
segment_np_handler:
mov eax, eax
create_halt_trap_handler exSegmentMsg

global double_fault_handler
double_fault_handler:
mov eax, eax
create_halt_trap_handler exDfMsg

global segment_overflow_handler
segment_overflow_handler:
mov eax, eax
create_halt_trap_handler exStSegOverflowMsg

global gp_fault_handler
gp_fault_handler:
mov eax, eax
create_halt_trap_handler exGpFaultMsg

global security_exception_handler
security_exception_handler:
mov eax, eax
create_halt_trap_handler exSecurityExMsg

section .data

idt:
	IDT_HANDLER_LOW_OFFSET equ $-idt
dw 0xFFFF			; base (lower bits)
	IDT_SEG_OFFSET equ $-idt
dw 0x0008			; segment
db 0x00				; unused
	IDT_HANDLER_TYPE_OFFSET equ $-idt
db 0b1000_1111		; type
	IDT_HANDLER_HIGH_OFFSET equ $-idt
dw 0xFFFF			; base (higher bits)
	IDT_HANDLER_SIZE equ $-idt

%rep 255
dw 0xDEAD		; handler low
dw 0xBEEF		; segment
db 0x00			; unused
db 0x0F 		; type
dw 0xCAFE		; handler (high)
%endrep

idt_end: 					; Used to calculate the size of the GDT
idt_desc: 					; The GDT descriptor 
	dw idt_end - idt - 1 	; Limit (size) 
	dd idt 					; Address of the GDT

section .rodata
exMsg db "@@ System execution error - CPU exception", 0
exDivideMsg db "Divide by zero", 0
exDfMsg db "Double fault", 0
exSegmentMsg db "Segment not present", 0
exStSegOverflowMsg db "Stack Segment Overflow", 0
exGpFaultMsg db "General Protection Fault", 0
exSecurityExMsg db "Security Exception", 0
exMsgHeader db "                 .               ", 0xA, "                 .               ", 0xA, "                 .       :       ", 0xA, "                 :      .        ", 0xA, "        :..   :  : :  .          ", 0xA, "           ..  ; :: .            ", 0xA, "              ... .. :..         ", 0xA, "             ::: :...            ", 0xA, "         ::.:.:...;; .....       ", 0xA, "      :..     .;.. :;     ..     ", 0xA, "            . :. .  ;.           ", 0xA, "             .: ;;: ;.           ", 0xA, "            :; .BRRRV;           ", 0xA, "               YB BMMMBR         ", 0xA, "              ;BVIMMMMMt         ", 0xA, "        .=YRBBBMMMMMMMB          ", 0xA, "      =RMMMMMMMMMMMMMM;          ", 0xA, "    ;BMMR=VMMMMMMMMMMMV.         ", 0xA, "   tMMR::VMMMMMMMMMMMMMB:        ", 0xA, "  tMMt ;BMMMMMMMMMMMMMMMB.       ", 0xA, " ;MMY ;MMMMMMMMMMMMMMMMMMV       ", 0xA, " XMB .BMMMMMMMMMMMMMMMMMMM:      ", 0xA, " BMI +MMMMMMMMMMMMMMMMMMMMi      ", 0xA, ".MM= XMMMMMMMMMMMMMMMMMMMMY      ", 0xA, " BMt YMMMMMMMMMMMMMMMMMMMMi      ", 0xA, " VMB +MMMMMMMMMMMMMMMMMMMM:      ", 0xA, " ;MM+ BMMMMMMMMMMMMMMMMMMR       ", 0xA, "  tMBVBMMMMMMMMMMMMMMMMMB.       ", 0xA, "   tMMMMMMMMMMMMMMMMMMMB:        ", 0xA, "    ;BMMMMMMMMMMMMMMMMY          ", 0xA, "      +BMMMMMMMMMMMBY:           ", 0xA, "        :+YRBBBRVt;", 0